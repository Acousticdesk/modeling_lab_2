<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Maxwell Distribution for particles of an idealized gas</title>
    <style>
        canvas {
            border: 1px solid #333;
        }

        table {
            margin: 20px 0;
        }

        th {
            position: sticky;
            background: #fff;
            top: 0;
        }

        td {
            text-align: center;
            padding: 10px 20px;
            border: 1px solid #333;
        }

        .tableContainer {
            display: inline-block;
            max-height: 480px;
            overflow: auto;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="640" height="480"></canvas>
    <canvas id="my_chart" width="640" height="480"></canvas>
    <div class="tableContainer">
        <table id="measurement_data">
            <thead>
            <tr>
                <th>Velocity of Oxygen Particle (m/s)</th>
                <th>Probability (%)</th>
            </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
<script>
    const T = 300; // Kelvins
    const kB = 1.38 * Math.pow(10, -23); // J/K

    // oxygen
    const m = 2.65 * Math.pow(10, -26); // kg

    // v is meters per second
    function probabilityOfASpeedOfAParticle(v) {
      return (4 / Math.sqrt(Math.PI)) * Math.pow(m / (2 * kB * T), 3/2) * Math.pow(v, 2) * Math.pow(Math.exp(1), ((-m * Math.pow(v, 2)) / (2 * kB * T)))
    }

    // console.log(v.map((vt) => probabilityOfASpeedOfAParticle(vt) * 100))

    // console.log(probabilityOfASpeedOfAParticle(300) / probabilityOfASpeedOfAParticle(100))

    function probability(n) {
      return !!n && Math.random() <= n;
    }

    const colors = ['#F0A202', '#F18805', '#D95D39', '#0E1428', '#0E1428', '#7B9E89']
    const directions = ['vertical', 'horizontal']
    const directionVectors = [-1, 1]

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    function setVelocity() {
      let speed = 100; // m/s
      const fallbackSpeed = 480; // m/s
      const maxSpeedToTry = 2000; // m/s
      let n = probabilityOfASpeedOfAParticle(speed);
      let chanceWorkedOut = probability(n);

      if (chanceWorkedOut) {
        return speed;
      }

      while (!chanceWorkedOut && speed < maxSpeedToTry) {
        speed += 10;
        n = probabilityOfASpeedOfAParticle(speed);
        chanceWorkedOut = probability(n);

        if (chanceWorkedOut) {
          return speed;
        }
      }

      return fallbackSpeed;
    }

    let particles = (new Array(1000)).fill({}).map(() => {
      return {
        x: Math.random() * canvas.clientWidth,
        y: Math.random() * canvas.clientHeight,
        color: colors[Math.round(Math.random() * (colors.length - 1))],
        direction: directions[Math.round(Math.random() * (directions.length - 1))],
        directionVector: directionVectors[Math.round(Math.random() * (directionVectors.length - 1))],
        velocity: setVelocity() / 1000
      };
    });

    function move() {
        particles = particles.map((particle) => {
          let nextDirectionVector = particle.directionVector;

          if (particle.direction === 'vertical') {
            if (particle.y <= 0) {
              nextDirectionVector = 1;
            } else if (particle.y >= canvas.clientHeight) {
              nextDirectionVector = -1;
            }
          }

          if (particle.direction === 'horizontal') {
            if (particle.x <= 0) {
              nextDirectionVector = 1;
            } else if (particle.x >= canvas.clientWidth) {
              nextDirectionVector = -1;
            }
          }

          return {
            ...particle,
            x: particle.direction === 'vertical' ? particle.x : particle.x + (particle.directionVector * particle.velocity),
            y: particle.direction === 'horizontal' ? particle.y : particle.y + (particle.directionVector * particle.velocity),
            directionVector: nextDirectionVector
          }
        })
    }

    function collisions() {
      particles.forEach((particle, index) => {
        particles.forEach((otherParticle, otherParticleIndex) => {
          if (index === otherParticleIndex) {
            return;
          }

          if ((particle.x === otherParticle.x) && (particle.y === otherParticle.y)) {
            particle.directionVector = particle.directionVector * -1;
            otherParticle.directionVector = otherParticle.directionVector * -1;
          }
        })
      });
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
      particles.forEach((particle) => {
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, 2, 0, 2 * Math.PI);
        ctx.fillStyle = particle.color;
        ctx.fill();
      });
    }

    function loop() {
      move();
      // collisions();
      draw();
      window.requestAnimationFrame(loop);
    }

    // todo: add collisions
    loop();
</script>
<script>
  function createPlotData() {
    let speed = 10; // m/s
    let result = [];

    while (speed <= 2000) {
      result.push({
        speed,
        probability: probabilityOfASpeedOfAParticle(speed)
      });
      speed += 10;
    }

    return result;
  }

  const plotData = createPlotData();

  const data = {
    labels: plotData.map((data) => data.speed),
    datasets: [{
      label: 'Maxwell-Boltzmann Distribution for Oxygen',
      data: plotData.map((data) => data.probability * 100),
      fill: false,
      borderColor: 'rgb(75, 192, 192)',
      tension: 0.1,
    }]
  };

  const config = {
    type: 'line',
    data: data,
    options: {
      responsive: false
    }
  };

  new Chart(document.getElementById('my_chart'), config);

  // populating the data with the measurements
  const table = document.getElementById('measurement_data').querySelector('tbody');

  plotData.forEach((data) => {
    const tr = document.createElement('tr');
    const speedTd = document.createElement('td');

    speedTd.textContent = data.speed

    const probabilityTd = document.createElement('td');

    probabilityTd.textContent = data.probability * 100;

    tr.appendChild(speedTd);
    tr.appendChild(probabilityTd);

    table.appendChild(tr);
  })
</script>
</html>
